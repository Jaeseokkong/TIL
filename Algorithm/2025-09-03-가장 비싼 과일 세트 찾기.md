# 🍎 가장 비싼 과일 세트 찾기

## 🧾 문제 설명
한 상점에는 여러 종류의 과일이 있습니다.  
각 과일에는 가격이 적혀 있으며, 같은 종류의 과일이 여러 개 있을 수 있습니다.  

상점 주인은 **3개의 과일을 골라 합산 가격을 기록**하려고 합니다.  
기록된 모든 합 중에서 **K번째로 높은 가격**을 구하세요.  
만약 K번째 가격이 존재하지 않으면 -1을 출력합니다.

### 📥 입력 예시
```js
let n = 7, k = 4;
let prices = [1200, 1500, 900, 2000, 800, 1500, 1000];
```

### 📤 출력 예시
```js
4200
```
---

## 📚 풀이 과정

### 💡 접근 방법
- 가능한 모든 3과일 조합의 합을 구한다.
- 중복 합이 존재할 수 있으므로 **Set**으로 중복 제거.
- 내림차순 정렬 후 K번째 값을 선택.

---

### 📝 내 풀이
```js
function solution(n, k, prices){
    prices.sort((a, b) => b - a); // 내림차순 정렬
    let count = 0;
    let answer;

    for(let i=0; i<n-2; i++){
        for(let j=i+1; j<n-1; j++){
            for(let s=j+1; s<n; s++){
                count++; // 단순히 조합 수를 세어 K번째가 나오면 반환
                if(count === k){
                    answer = prices[i]+prices[j]+prices[s];
                    break;
                }
            }
        }
    }
    return answer;
}
```
#### ❌ 문제점  
1. **중복 합 처리 실패**
- 같은 합이 여러 번 나와도 `count++`가 계속 증가 → 실제 K번째 큰 값이 아님
- 예: `[5,5,5,3]` 같은 경우, 15가 여러 번 세어지면서 K번째 값이 틀릴 수 있음

2. **Set 사용 없이 정렬만으로 조기 종료**
- 내림차순 정렬 후에도 루프에서 count로 K번째 값 찾는 방식은 합이 떨어진 순서와 반드시 일치하지 않음

3. **K번째 값이 존재하지 않을 경우 처리 없음**
- 배열 길이보다 큰 K가 들어오면 undefined 반환

---

### ✅ 정답 코드
<details>
<summary>
<strong style="cursor: pointer">정답 보기 🔍</strong>
</summary> 
<pre>
<code class="language-js"> 
function solution(n, k, prices) {
    let sums = new Set();

    for (let i = 0; i < n - 2; i++) {
        for (let j = i + 1; j < n - 1; j++) {
            for (let s = j + 1; s < n; s++) {
                sums.add(prices[i] + prices[j] + prices[s]); // 중복 제거
            }
        }
    }

    // Set을 Array로 변환 후 내림차순 정렬
    let sorted = Array.from(sums).sort((a, b) => b - a);

    // K번째 값이 존재하면 반환, 없으면 -1
    return sorted[k - 1] ?? -1;
}

// 테스트
let n = 7, k = 4;
let prices = [1200, 1500, 900, 2000, 800, 1500, 1000];
console.log(solution(n, k, prices)); 
</code>
</pre>
</details>

#### 🔹 특징
- 모든 조합의 합을 **Set으로 중복 제거**
- **정확한 내림차순 정렬** 후 K번째 값 선택
- K가 존재하지 않을 경우 **-1 반환**

---

## 📌 마무리 회고
- **처음 시도**: 단순히 내림차순 정렬 후 반복문에서 count++로 K번째 값을 찾으려 함 → 중복 합이 섞이면 K번째 값이 틀릴 수 있음.
- **정답 풀이**: 모든 조합 합을 **Set으로 중복 제거** → 내림차순 정렬 → K번째 값 선택 → 정확하게 결과 보장.
- **느낀 점**: “모든 조합 생성 + 중복 제거 + 순서대로 선택” 패턴 기억 → 반복문만 믿고 K번째 값 찾기 실수 방지.
