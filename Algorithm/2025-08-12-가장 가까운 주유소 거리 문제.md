# 💼 가장 가까운 주유소 거리 문제

## 🧾 문제 설명
고속도로를 나타내는 문자열 `road` 가 주어집니다.
문자열에는 빈 도로(`.`)와 주요소(`G`)가 표시되어 있습니다.
각 도로 위치에서 가장 가까운 주유소(`G`)까지의 **최소 거리**를 계산하십시오.

### 📥 입력 예시
```js
let road = "..G....G..G.";
```

### 📥 출력 예시
```js
[2, 1, 0, 1, 2, 3, 0, 1, 0, 1, 2, 3]
```

### 목표
- 각 인덱스의 문자에서 `G` 까지 떨어진 최소 거리를 구하기
- 도로 길이는 최대 100, `G` 는 하나 이상 존재

---

## 풀이 과정

### 💡 접근 방법
- **왼쪽 → 오른쪽 탐색** : 왼쪽에 있는 가장 가까운 주유소까지 거리 계산
- **오른쪽 → 왼쪽 탐색** : 오른쪽에 있는 가장 가까운 주유소까지 거리 계산
- 두 값 중 **작은 값** 을 선택하여 최소 거리 결정

#### 🤔 처음에는
> `forward` 와 `reverse` 라는 배열 두 개를 만들고,
각각 왼쪽→오른쪽, 오른쪽→왼쪽 방향으로 탐색한 후,
마지막에 두 배열을 비교하여 최소값을 구했습니다.
다만 초기값을 크게 주고, 조건문이 많아 코드가 길어졌습니다.

```js
function solution(road, t){
	let answer = [];
	let forward = [];
	let reverse = [];
	const len = road.length;

	let forwardStandard = -1;
	let reverseStandard = -1;
	for (let i = 0; i < len; i++) {
		if (road[i] !== t && forwardStandard === -1) forward.push(len + 1);
		else if (road[i] === t) {
			forwardStandard = i;
			forward.push(0);
		} else {
			forward.push(i - forwardStandard);
		}

		if (road[len - 1 - i] !== t && reverseStandard === -1) reverse.unshift(len + 1);
		else if (road[len - 1 - i] === t) {
			reverseStandard = i;
			reverse.unshift(0);
		} else {
			reverse.unshift(i - reverseStandard);
		}
	}

	for (let i = 0; i < len; i++ ) {
		answer.push(Math.min(forward[i], reverse[i]));
	}

	return answer;
}

let road="..G....G..G.";
console.log(solution(road, 'G'));
```

### ✅ 정답 코드
<details>
<summary>
<strong style="cursor: pointer">정답 보기 🔍</strong>
</summary> 
<pre>
<code class="language-js"> 
function solution(road, t){
	let answer = [];
	let p = road.length;
	for (let i = 0; i < road.length; i++) {
		if (road[i] === t) {
			p = 0
		} else {
			p++
		}
		answer.push(p)
	}

	p = road.length;
	for (let i = road.length - 1; i >= 0; i--) {
		if (road[i] === t) {
			p = 0
		} else {
			p++
		}
		answer[i] = Math.min(answer[i], p)
	}
}

let road="..G....G..G.";
console.log(solution(road, 'G'));
</code>
</pre>
</details>

---

## 📌 마무리 회고
- 내 풀이는 동작은 하지만 **조건문과 배열 조작**이 많아 코드가 복잡
- 정답 풀이처럼 `p`(거리)를 하나만 두고 **두 번의 선형 탐색**으로 해결하면 훨씬 깔끔