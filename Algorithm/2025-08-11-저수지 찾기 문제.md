# 💼 격자판 저수지 찾기 문제

## 🧾 문제 설명
N×N 격자판에 각 지역의 **물 깊이**가 주어집니다.
자신의 상, 하, 좌, 우의 깊이보다 더 깊은 지역은 저수지로 분류합니다.
격자의 가장자리는 깊이가 0이라고 가정합니다.

### 📥 입력 예시
```js
let depthMap = [
  [4, 2, 5, 1, 3],
  [3, 6, 2, 7, 2],
  [5, 3, 8, 4, 6],
  [4, 5, 7, 3, 2],
  [6, 4, 2, 5, 1]
];
```
- 각 숫자는 해당 지역의 물 깊이 (정수, 최대 100)
- 단, 인덱스 범위 밖은 깊이가 0으로 간주

### 🎯 목표
격자판에서 저수지의 개수를 구하시오.

---

## 📚 풀이 과정
### 💡 접근 방법
- 각 좌표 `(i, j)`를 중심으로 상, 하, 좌, 우 4방향 값을 확인
- 4방향 모두 현재 값보다 깊이가 얕으면 저수지로 판단

#### 🤔 처음에는
> 상·하·좌·우를 변수로 각각 저장한 후 비교하는 조건문을 작성했습니다.
동작은 하지만, 코드 길이가 길어지고 방향이 늘어나면 수정이 어렵습니다.

### 📌 내가 작성한 코드
```js
function solution(arr){
	let count = 0;
	let n = arr.length;
	for (let i = 0; i < n; i++) {
		for (let j = 0; j < n; j++) {
			
			let left = j - 1 >= 0 ? arr[i][j-1] : 0
			let right = j + 1 < n ? arr[i][j+1] : 0 
			let top = i - 1 >= 0 ? arr[i-1][j] : 0
			let bottom = i + 1 < n ? arr[i+1][j] : 0
			
			const current = arr[i][j]
			if (current > left && current > right && current > top && current > bottom) count++;
		}
	}

	return count;
}

let depthMap = [
  [4, 2, 5, 1, 3],
  [3, 6, 2, 7, 2],
  [5, 3, 8, 4, 6],
  [4, 5, 7, 3, 2],
  [6, 4, 2, 5, 1]
];
console.log(solution(depthMap));
```

### ✅ 정답 코드
<details>
	<summary>
		<strong style="cursor: pointer">정답 보기 🔍</strong>
	</summary> 
	<pre>
		<code class="language-js"> 
function solution(arr){  
	let answer = 0;
	let n = arr.length;
	let dx = [-1, 0, 1, 0];
	let dy = [0, 1, 0, -1];
	for(let i = 0; i < n; i++){
		for(let j = 0; j < n; j++){
			let flag = 1;
			for(let k = 0; k < 4; k++){
				let nx = i + dx[k];
				let ny = j + dy[k];
				if(nx >= 0 && nx < n && ny >= 0 && ny < n && arr[nx][ny] >= arr[i][j]){
					flag = 0;
					break;
				}
			}
			if(flag) answer++;
		}
	}
	return answer;
}
let depthMap = [
	[4, 2, 5, 1, 3],
	[3, 6, 2, 7, 2],
	[5, 3, 8, 4, 6],
	[4, 5, 7, 3, 2],
	[6, 4, 2, 5, 1]
];
console.log(solution(depthMap));

		</code>
	</pre>
</details>

---

## 📌 마무리 회고
- 내 코드
	-	직관적으로 변수(`left`, `right`, `top`, `bottom`)를 만들어 비교
	- 가독성은 좋지만, 방향이 늘어나면 변수 추가와 조건식 수정이 필요 → 유지보수 어려움
	- 예를 들어 대각선까지 포함해야 하면 4개의 변수를 더 만들어야 함

- 정답 코드
	- 방향 배열(`dx`, `dy`)을 사용 → 반복문만 수정하면 손쉽게 방향 확장 가능
	- 4방향 → 8방향 변경 시 dx, dy 배열에 값만 추가하면 됨
	- 코드 **재사용성**과 **확장성**이 뛰어남

➡️ 결론: 격자판 문제에서는 방향 배열을 활용하는 방식이 유지보수·확장성 면에서 유리하다.

