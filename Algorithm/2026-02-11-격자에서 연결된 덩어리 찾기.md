# ğŸ¥– 2ì°¨ì› ê²©ìì—ì„œ ì—°ê²°ëœ ë©ì–´ë¦¬ ì°©ê¸°

2ì°¨ì–¼ ê²©ì ë¬¸ì œì—ì„œ ìƒí•˜ì¢Œìš°ë¡œ ì—°ê²°ëœ ì˜ì—­(ë©ì–´ë¦¬)ì˜ ë¬¸ì œë“¤ì€ ì„¬ ê°œìˆ˜, ì˜ì—­ í¬ê¸° ê³„ì‚°, í¼ì§ ì‹œë®¬ë ˆì´ì…˜ ë“± ë‹¤ì–‘í•œ ë¬¸ì œì—ì„œ ë°˜ë³µì ìœ¼ë¡œ ë“±ì¥í•©ë‹ˆë‹¤.

í•µì‹¬ì€ **BFS ë˜ëŠ” DFSë¥¼ ì´ìš©í•˜ì—¬ ì—°ê²°ëœ ì˜ì—­ì„ í•œ ë²ˆì— íƒìƒ‰í•˜ëŠ” ê²ƒ**ì…ë‹ˆë‹¤.

---

## 1ï¸âƒ£ í•µì‹¬ ê°œë…

### ğŸ”¹ ì—°ê²°ëœ ë©ì–´ë¦¬ë€?

- ìƒ, í•˜, ì¢Œ, ìš°ë¡œ ì´ì–´ì§„ ë™ì¼í•œ ê°’ì˜ ì§‘í•©
- í•˜ë‚˜ì˜ ì‹œì‘ì ì—ì„œ BFS/DFSë¥¼ ìˆ˜í–‰í•˜ë©´ í•˜ë‚˜ì˜ ë©ì–´ë¦¬ë¥¼ ì „ë¶€ ë°©ë¬¸ ê°€ëŠ¥

---

### ğŸ”¹ ê¸°ë³¸ ë¬¸ì œ íŒ¨í„´

1. ê²©ìë¥¼ ì „ì²´ ìˆœíšŒ
2. ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ íŠ¹ì • ê°’(ì˜ˆ: 1)ì„ ë°œê²¬
3. BFS/DFS ì‹œì‘
4. ì—°ê²°ëœ ì˜ì—­ ì „ë¶€ ë°©ë¬¸ ì²˜ë¦¬
5. BFS/DFS 1íšŒ = ë©ì–´ë¦¬ 1ê°œ

---

### ğŸ”¹ ê±°ì˜ ë“±ì¥í•˜ëŠ” ìš”ì†Œ

- ë°©ë¬¸ ë°°ì—´ (visited)
- ë°©í–¥ ë°°ì—´ (dx, dy)
- ë²”ìœ„ ì²´í¬ (nx >= 0 ...)

---

## 2ï¸âƒ£ ì˜ˆì‹œ ë¬¸ì œ - ì„¬ì˜ ê°œìˆ˜ êµ¬í•˜ê¸°

### ğŸ“„ ë¬¸ì œ

2ì°¨ì› ê²©ì `grid`ê°€ ì£¼ì–´ì§„ë‹¤.

- `"1"` â†’ ë•…
- `"0"` â†’ ë°”ë‹¤

ìƒí•˜ì¢Œìš°ë¡œ ì—°ê²°ëœ ë•…ì€ í•˜ë‚˜ì˜ ì„¬ì´ë‹¤. ì„¬ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ì‹œì˜¤.

```arduino
ì…ë ¥
[
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]

ì¶œë ¥
3
```

---

### ğŸ’¡ í’€ì´ ì•„ì´ë””ì–´

- ê²©ìë¥¼ ì „ì²´ íƒìƒ‰
- ë°©ë¬¸í•˜ì§€ ì•Šì€ `"1"` ë°œê²¬ ì‹œ BFS ì‹œì‘
- ì—°ê²°ëœ ëª¨ë“  `"1"` ë°©ë¬¸ ì²˜ë¦¬
- BFS íšŸìˆ˜ = ì„¬ ê°œìˆ˜

### ğŸ§ ì˜ˆì‹œ ì½”ë“œ 

```js
function solution(grid) {
	const n = grid.length;
	const m = grid[0].length;

	const visited = Array.from({ length: n }, () => Array(m).fill(false));

	cosnt dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]] //ìƒ,í•˜,ì¢Œ,ìš°
	let answer = 0;

	for (let i = 0; i < n; i++) {
		for (let j = 0; j < m; j++) {
			if (grid[i][j] === "1" && !visited[i][j]) { // ì„¬ ì²´í¬ & ë¯¸ë°©ë¬¸
				answer++; // ë©ì–´ë¦¬ ì´ˆê¸° ì§„ì… ì‹œ ê°œìˆ˜ ì²´í¬

				const queue = [[i, j]];
				visited[i][j] = true;

				while (queue.length) {
					cosnt [x, y] = queue.shift();

					for (let [dx, dy] of [dirs]) {
						const nx = x + dx;
						const ny = y + dy;

						if (nx >= 0 && ny >= 0 && nx < n && ny < m && grid[nx][ny] === "1" && !visited[i][j]) {
							visited[i][j] = true;
							queue.push([nx, ny]);
						}
					}
				}
			}
		}
	}

	return ansewr;
}
```