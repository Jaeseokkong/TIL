# 💼 모든 경기에서 더 빠른 선수 찾기

## 🧾 문제 설명
N명의 선수가 M번의 달리기 경기에 참가했습니다.  
(선수 A, 선수 B) 쌍을 만들 때, **A가 모든 경기에서 B보다 항상 빠른 기록(작은 순위)** 을 가질 경우 A는 B보다 우수하다고 정의합니다.

이때 가능한 `(A, B)` 쌍의 개수를 출력하세요.

### 📥 입력 예시
```js
let records = [
  [2, 3, 1, 4], 
  [3, 4, 1, 2], 
  [2, 1, 3, 4]
];
```


### 📤 출력 예시
```js
2
```
가능한 경우는 `(2,1)`, `(3,1)` 두 가지.

### 🎯 목표
- 모든 경기 결과를 확인
- (A, B) 가능한 쌍을 탐색
- 조건을 만족하는 경우를 카운트
---

## 📚 풀이 과정

### 💡 접근 방법

- 각 선수 쌍 `(i, j)`를 전부 확인
- 각 경기마다 두 선수의 순위 비교
- 모든 경기에서 `i < j`라면 `(i, j)` 성립

---

### 📝 내 풀이
```js
function solution(arr){
    let answer = [];
    for (let i = 0; i < arr[0].length - 1; i++) {
        let standard = arr[0][i];
        let standardList = arr[0].slice(i + 1);

        for (let j = 1; j < arr.length; j++) {
            let canList = [];
            let pos = arr[j].indexOf(standard);
            for (let k = pos + 1; k < arr[j].length; k++) {
                if (standardList.indexOf(arr[j][k]) >= 0) {
                    canList.push(arr[j][k]);
                }
            }
            standardList = [...canList];
        }

        if (standardList.length > 0) {
            for (let n of standardList) {
                answer.push([standard, n]);
            }
        }
    }
    console.log(answer); // 확인용
    return answer.length;
}

let records = [
  [2, 3, 1, 4], 
  [3, 4, 1, 2], 
  [2, 1, 3, 4]
];
console.log(solution(records)); // 2
```

---

### ✅ 정답 코드
<details>
    <summary>
    <strong style="cursor: pointer">정답 보기 🔍</strong> 
    </summary>
        <pre><code class="language-js">
function solution(test) { 
    let answer = 0; let m = test.length; let n = test[0].length;
    for(let i = 1; i <= n; i++){
        for(let j = 1; j <= n; j++){
            if(i === j) continue;
            let cnt = 0;
            for(let k = 0; k < m; k++){
                let pi = 0, pj = 0;
                for(let s = 0; s < n; s++){
                    if(test[k][s] === i) pi = s;
                    if(test[k][s] === j) pj = s;
                }
                if(pi < pj) cnt++;
            }
            if(cnt === m) answer++;
        }
    }
    return answer;
}
let records = [
    [2, 3, 1, 4],
    [3, 4, 1, 2],
    [2, 1, 3, 4]
];
console.log(solution(records)); // 2
</code>
</pre>
</details>

---

## 📌 마무리 회고
- **내 풀이**: 첫 번째 경기 기준으로 후보군을 좁혀가는 방식 → 아이디어는 새롭지만 배열 조작이 많아 복잡해짐.
- **정답 풀이**: 모든 쌍 (i, j)를 탐색해 전부 비교 → 단순하고 직관적이며 확장성 좋음.
- **느낀 점**: 이런 유형은 "모든 경기에서 우위 확인"이 핵심이라, **쌍 비교 + 전부 확인** 방식이 안정적.