# 💾 동적계획법 (Dynamic Programming, DP)

**동적계획법(Dynamic Programming)** 은  
복잡한 문제를 **작은 부분 문제(Subproblem)** 로 나누어 해결하고,  
그 결과를 저장(Memoization) 하여 **중복 계산을 피하는 알고리즘 기법**입니다.

---

## 1️⃣ 핵심 개념

> **"큰 문제를 작은 문제로 나누고, 결과를 재활용한다"**

즉, 같은 계산을 여러 번 하지 않도록  
**이미 계산한 값을 저장** 해두고 다시 사용할 수 있게 하는 것이 핵심입니다.

**이를 통해 시간 복잡도를 획기적으로 줄일 수 있습니다.**

---

## 2️⃣ 적용 조건

동적계획법은 **“비슷한 계산을 여러 번 해야 하는 문제”** 에서 특히 유용합니다.


|조건|설명|
|:---|:---|
|**① 비슷한 계산이 반복됨 (중복되는 부분 문제)**|큰 문제를 풀다 보면 **같은 계산을 여러 번 하게 됨.**  <br> 예: 피보나치 수열에서 `f(3)`을 계산할 때 
f(2)`를 여러 번 구함.|
|**② 부분 답을 이용해 전체 답을 만들 수 있음 (최적 부분 구조)**|**작은 문제의 정답을 이용해 큰 문제의 정답을 만들 수 있음.** <br> 예: "지금까지의 최적 선택"이 "전체의 최적 선택"으로 이어짐.|

👉 이 두 가지 조건이 모두 맞을 때,  
**동적계획법(DP)** 으로 문제를 훨씬 효율적으로 풀 수 있습니다.

---

## 3️⃣ 예시: 배낭 문제 (Knapsack Problem)

> 문제  
무게 제한이 있는 배낭에 물건을 넣을 때,  
**총 가치가 최대**가 되도록 어떤 물건을 선택해야 할까?

|      물건      |   무게  |  가치 |
| :----------: | :---: | :-: |
|       1      |   2   |  3  |
|       2      |   3   |  4  |
|       3      |   4   |  5  |
| **배낭 최대 무게** | **5** |     |


---

### 🧠 아이디어

모든 경우르 다 시도하는 대신,  
**"지금 물건을 넣을까, 말까?"** 두 가지 선택 중  
더 좋은 결과를 DP로 저장하며 결정합니다.

---

### ⚙️ Bottom-Up 방식

```js
function knapsack(weights, values, maxWeight) {
  const n = weights.length;
  const dp = Array.from({ length: n + 1 }, () => Array(maxWeight + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let w = 1; w <= maxWeight; w++) {
      if (weights[i - 1] <= w) {
        dp[i][w] = Math.max(
          dp[i - 1][w], // 현재 물건을 안 넣는 경우
          dp[i - 1][w - weights[i - 1]] + values[i - 1] // 넣는 경우 (이전 무게를 빼고 넣음)
        );
      } else {
        dp[i][w] = dp[i - 1][w];
      }
    }
  }

  return dp[n][maxWeight];
}

const weights = [2, 3, 4];
const values = [3, 4, 5];
const maxWeight = 5;

console.log(knapsack(weights, values, maxWeight)); // ✅ 출력: 7
```

#### 📊 DP 테이블 개념 (시각적으로 보면)

| i(물건) | w=0 | w=1 | w=2 | w=3 | w=4 | w=5 |
| :---: | --: | --: | --: | --: | --: | --: |
|   0   |   0 |   0 |   0 |   0 |   0 |   0 |
|   1   |   0 |   0 |   3 |   3 |   3 |   3 |
|   2   |   0 |   0 |   3 |   4 |   4 |   7 |
|   3   |   0 |   0 |   3 |   4 |   5 |   7 |

✅ 결과: **최대 가치 = 7**
(1번, 2번 물건을 넣으면 무게 5, 가치 7)

---