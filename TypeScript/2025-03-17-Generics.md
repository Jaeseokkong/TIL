# Generics
제너릭은 **타입을 변수처럼 사용할 수 있도록 해주는 TypeScript의 기능**입니다. 이를 통해 함수, 클래스, 인터페이스 등에서 **다양한 타입을 유연하게 처리**할 수 있습니다.

<br>

## 1️⃣ 기본 개념
### 🔹 제너릭 함수
```ts
function identity<T>(arg: T): T {
  return arg;
}
console.log(identity<string>("Hello")); // "Hello"
console.log(identity<number>(42)); // 42
```
✔️ `T`는 **타입 변수**로 호출할 때 타입을 지정할 수 있습니다.  
✔️ 함수 호출 시 타입을 명시적으로 지정하거나, 타입 추론이 가능합니다.

<br>

- - -

<br>

## 2️⃣ 활용 예시
### 🔹 제너릭 인터페이스
```ts
interface KeyValuePair<K, V> {
  key: K;
  value: V;
}
const kv1: KeyValuePair<string, number> = { key: "age", value: 30 };
const kv2: KeyValuePair<number, boolean> = { key: 1, value: true };
```
✔️ `K`와 `V`는 호출 시 타입을 동적으로 지정할 수 있습니다.

<br>

### 🔹 제너릭 클래스
```ts
class DataStorage<T> {
  private data: T[] = [];

  addItem(item: T) {
    this.data.push(item);
  }

  getItems(): T[] {
    return this.data;
  }

  const textStorage = new DataStorage<string>();
  textStorage.addItem("Apple");
  console.log(textStorage.getItems()); // ["Apple"]
}
```
✔️ 제너릭을 활용해 **다양한 타입의 데이터 저장소를 만들 수 있습니다.**

<br>

### 🔹 제너릭 제한 (Constraints)
```ts
function logLength<T extends { length: number }>(arg: T): number {
  return arg.length
}

console.log(logLength("Hello")); // 5
console.log(logLength([1, 2, 3])); // 3
```
✔️ `T extends { length: number }`를 사용하여 **특정 속성ㅇ르 가진 타입만 허용할 수 있습니다.**

<br>

###  🔹 `keyof`와 함께 사용하기
```ts
function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

const person = { name: "Alice", age: 25 };
console.log(getProperty(person, "name")); // "Alice"
```
✔️ `K extends keyof T` 를 활용하면 **객체의 키를 제한할 수 있습니다.**

<br>

### 기본 타입 지정 (Default Type)
```ts
function createArray<T = string>(length: number, value: T): T[] {
  return new Array(length).fill(value)
}
```
✔️ `<T = string>`을 통해 기본 타입을 지정할 수 있습니다.